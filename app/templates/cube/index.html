<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Responsive 3D Rubik's Cube</title>
    <style>
        /* Responsive sizing variables */
        :root {
            /* Cube size scales between 40px and 65px per cubie based on screen width */
            --size: clamp(40px, 8vw, 65px); 
            --offset: calc(var(--size) + 2px);
        }

        body {
            background: #111;
            color: white;
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Centering the entire UI */
        .app-container {
            display: flex;
            flex: 1;
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Sidebar for buttons - moves to bottom on mobile */
        .sidebar {
            width: 80px;
            background: rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px;
            z-index: 10;
            justify-content: center;
            border-right: 1px solid #333;
        }

        /* Middle area where cube lives */
        .cube-viewport {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            perspective: 1200px;
            overflow: hidden;
            position: relative;
        }

        /* HUD - Stats at the top */
        .hud {
            position: absolute;
            top: 20px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 30px;
            font-size: clamp(1rem, 4vw, 1.5rem);
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
        }

        /* Bottom Controls */
        .bottom-ui {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 15px;
            z-index: 20;
        }

        button {
            padding: 12px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background: #444;
            color: white;
            font-weight: bold;
            transition: 0.2s;
            font-size: 14px;
        }

        button:hover { background: #666; transform: translateY(-2px); }
        .scramble-btn { background: #d35400; }
        .reset-btn { background: #2980b9; }

        /* Cube Visuals */
        #cube-pivot {
            position: relative;
            width: 0; height: 0;
            transform-style: preserve-3d;
            transition: transform 0.1s linear;
        }

        .cubie {
            position: absolute;
            width: var(--size);
            height: var(--size);
            transform-style: preserve-3d;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .face {
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid #000;
            box-sizing: border-box;
            border-radius: 10%;
            backface-visibility: hidden;
        }

        /* Face Color Mapping */
        .f { background: #e67e22; transform: rotateY(0deg) translateZ(calc(var(--size)/2)); }
        .b { background: #f1c40f; transform: rotateY(180deg) translateZ(calc(var(--size)/2)); }
        .r { background: #2ecc71; transform: rotateY(90deg) translateZ(calc(var(--size)/2)); }
        .l { background: #3498db; transform: rotateY(-90deg) translateZ(calc(var(--size)/2)); }
        .u { background: #fff;    transform: rotateX(90deg) translateZ(calc(var(--size)/2)); }
        .d { background: #e74c3c; transform: rotateX(-90deg) translateZ(calc(var(--size)/2)); }

        /* Mobile Adjustments */
        @media (max-width: 600px) {
            .app-container { flex-direction: column-reverse; }
            .sidebar { 
                width: 100%; 
                flex-direction: row; 
                height: 60px; 
                overflow-x: auto; 
                padding: 5px; 
                border-right: none;
                border-top: 1px solid #333;
            }
            .sidebar button { min-width: 50px; padding: 5px; }
            .hud { top: 10px; }
            .bottom-ui { bottom: 80px; }
        }
    </style>
</head>
<body>

<div class="app-container">
    <div class="sidebar" id="sideButtons">
        <button onclick="handleMove('x', 1, 90)">R</button>
        <button onclick="handleMove('x', -1, -90)">L</button>
        <button onclick="handleMove('y', -1, 90)">U</button>
        <button onclick="handleMove('y', 1, -90)">D</button>
        <button onclick="handleMove('z', 1, 90)">F</button>
        <button onclick="handleMove('z', -1, -90)">B</button>
    </div>

    <div class="cube-viewport" id="viewport">
        <div class="hud">
            <span>Moves: <span id="move-count">0</span></span>
            <span>Time: <span id="timer">00:00</span></span>
        </div>

        <div id="cube-pivot"></div>

        <div class="bottom-ui">
            <button class="scramble-btn" onclick="scramble()">ðŸŽ¯ Scramble</button>
            <button class="reset-btn" onclick="reset()">ðŸ”„ Reset</button>
        </div>
    </div>
</div>

<script>
    const pivot = document.getElementById('cube-pivot');
    let cubies = [];
    let moves = 0, seconds = 0, timerInterval = null;
    let isDragging = false, startX, startY;
    let cubeRot = { x: -30, y: 45 };
    let activeCubie = null;

    function init() {
        pivot.innerHTML = '';
        cubies = [];
        moves = 0; seconds = 0;
        document.getElementById('move-count').innerText = "0";
        document.getElementById('timer').innerText = "00:00";
        clearInterval(timerInterval);
        timerInterval = null;

        for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
                for (let z = -1; z <= 1; z++) {
                    if (x === 0 && y === 0 && z === 0) continue;
                    const el = document.createElement('div');
                    el.className = 'cubie';
                    ['f','b','r','l','u','d'].forEach(f => {
                        const face = document.createElement('div');
                        face.className = `face ${f}`;
                        el.appendChild(face);
                    });
                    const cubie = { el, x, y, z, rx: 0, ry: 0, rz: 0 };
                    cubies.push(cubie);
                    pivot.appendChild(el);
                    updateCubiePos(cubie);
                }
            }
        }
        pivot.style.transform = `rotateX(${cubeRot.x}deg) rotateY(${cubeRot.y}deg)`;
    }

    function updateCubiePos(c) {
        // Use the CSS variable for the gap calculation
        const sizeStr = getComputedStyle(document.documentElement).getPropertyValue('--size');
        const size = parseInt(sizeStr.replace('px', '')) || 60;
        const offset = size + 2;
        
        c.el.style.transform = `translate3d(${c.x * offset}px, ${c.y * offset}px, ${c.z * offset}px) rotateX(${c.rx}deg) rotateY(${c.ry}deg) rotateZ(${c.rz}deg)`;
    }

    function handleMove(axis, layer, deg) {
        if (!timerInterval) startTimer();
        moves++;
        document.getElementById('move-count').innerText = moves;

        cubies.forEach(c => {
            if (Math.round(c[axis]) === layer) {
                if (axis === 'x') {
                    let y = c.y, z = c.z;
                    c.y = deg > 0 ? -z : z;
                    c.z = deg > 0 ? y : -y;
                    c.rx += deg;
                } else if (axis === 'y') {
                    let x = c.x, z = c.z;
                    c.x = deg > 0 ? z : -z;
                    c.z = deg > 0 ? -x : x;
                    c.ry += deg;
                } else if (axis === 'z') {
                    let x = c.x, y = c.y;
                    c.x = deg > 0 ? -y : y;
                    c.y = deg > 0 ? x : -x;
                    c.rz += deg;
                }
                updateCubiePos(c);
            }
        });
    }

    // Interaction logic
    document.addEventListener('mousedown', e => {
        isDragging = true;
        startX = e.clientX; startY = e.clientY;
        activeCubie = e.target.closest('.cubie');
    });

    document.addEventListener('mousemove', e => {
        if (!isDragging) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;

        if (activeCubie && (Math.abs(dx) > 40 || Math.abs(dy) > 40)) {
            const c = cubies.find(cb => cb.el === activeCubie);
            if (Math.abs(dx) > Math.abs(dy)) handleMove('y', c.y, dx > 0 ? 90 : -90);
            else handleMove('x', c.x, dy > 0 ? 90 : -90);
            isDragging = false; 
        } else if (!activeCubie) {
            cubeRot.y += dx * 0.4;
            cubeRot.x -= dy * 0.4;
            pivot.style.transform = `rotateX(${cubeRot.x}deg) rotateY(${cubeRot.y}deg)`;
            startX = e.clientX; startY = e.clientY;
        }
    });

    document.addEventListener('mouseup', () => { isDragging = false; activeCubie = null; });

    function startTimer() {
        timerInterval = setInterval(() => {
            seconds++;
            let m = Math.floor(seconds / 60).toString().padStart(2, '0');
            let s = (seconds % 60).toString().padStart(2, '0');
            document.getElementById('timer').innerText = `${m}:${s}`;
        }, 1000);
    }

    function scramble() {
        let count = 0;
        const axes = ['x','y','z'];
        const layers = [-1, 0, 1];
        const interval = setInterval(() => {
            handleMove(axes[Math.floor(Math.random()*3)], layers[Math.floor(Math.random()*3)], 90);
            if (++count > 15) clearInterval(interval);
        }, 120);
    }

    function reset() { init(); }
    init();
</script>
</body>
</html>